#!/usr/bin/env python3
#
################################################################################
# SFSXplorer                                                                   #
# Scoring Function Space eXplorer                                              #
################################################################################
#
# SFSXplorer reads input files generated by SAnDReS 2.0 (Xavier et al., 2016)
# (pdbqt and bind_#####.csv files) to create targeted scoring functions
# (Seifert, 2009). This program calculates energy terms loosely based on the
# AutoDock 4 Force Field (Morris et al., 1998; 2009) to explore the
# Scoring Function Space concept (Ross et al., 2013; Heck et al., 2017;
# Bitencourt-Ferreira & de Azevedo Jr., 2019; Veríssimo et al., 2022). We may
# vary the exponents of van der Waals and hydrogen-bond potentials and the
# parameters used to determine the electrostatic (Bitencourt-Ferreira & de
# Azevedo Jr., 2021) and desolvation potentials.
#
# References:
# Bitencourt-Ferreira G, de Azevedo WF Jr. Exploring the Scoring Function Space.
# Methods Mol Biol. 2019; 2053: 275–281.
#
# Bitencourt-Ferreira G, de Azevedo Junior WF. Electrostatic Potential Energy in
# Protein-Drug Complexes. Curr Med Chem. 2021; 28(24): 4954–4971.
#
# Heck GS, Pintro VO, Pereira RR, de Ávila MB, Levin NMB, de Azevedo WF.
# Supervised Machine Learning Methods Applied to Predict Ligand-Binding
# Affinity. Curr Med Chem. 2017; 24(23): 2459–2470.
#
# Morris GM, Goodsell D, Halliday R, Huey R, Hart W, Belew R, Olson A.
# Automated docking using a Lamarckian genetic algorithm and an empirical
# binding free energy function. J Comput Chem. 1998; 19: 1639–1662.
#
# Morris GM, Huey R, Lindstrom W, Sanner MF, Belew RK, Goodsell DS, Olson AJ.
# AutoDock4 and AutoDockTools4: Automated docking with
# selective receptor flexibility. J Comput Chem. 2009; 30(16): 2785–2791.
#
# Ross GA, Morris GM, Biggin PC. One Size Does Not Fit All: The Limits of
# Structure-Based Models in Drug Discovery. J Chem Theory Comput. 2013; 9(9):
# 4266–4274.
#
# Seifert MH. Targeted scoring functions for virtual screening. Drug Discov
# Today. 2009; 14(11-12): 562–569.
#
# Xavier MM, Heck GS, Avila MB, Levin NMB, Pintro VO, Carvalho NL, Azevedo WF.
# SAnDReS: a Computational Tool for Statistical Analysis of Docking Results and
# Development of Scoring Functions. Comb Chem High Throughput Screen. 2016;
# 9(10):801–812.
#
# Veríssimo GC, Serafim MSM, Kronenberger T, Ferreira RS, Honorio KM,
# Maltarollo VG. Designing drugs when there is low data availability:
# one-shot learning and other approaches to face the issues of a
# long-term concern. Expert Opin Drug Discov. 2022; 17(9): 929–947.
#
################################################################################
# Dr. Walter F. de Azevedo, Jr.                                                #
# https://azevedolab.net/                                                      #
# January 12, 2023                                                             #
################################################################################
#
# Define Plot_V() class
class Plot_V(object):
    """Class to generate plot of potential energy terms"""

    # Define constructor method
    def __init__(self,plot_in,plot_out,dpi_in):
        """Constructor method"""

        # Define attributes
        self.plot_in = plot_in
        self.plot_out = plot_out
        self.dpi_in = dpi_in

        print("\nGenerating ",self.plot_out," plot...",end=" ")

    # Define read_plot_parameters()
    def read_plot_parameters(self):
        """Read plot parameters"""

        # Import section
        import csv
        import sys
        import numpy as np

        # Try to open csv file
        try:
            fo1 = open(self.plot_in,"r")
            my_csv1 = csv.reader(fo1)
        except IOError:
            sys.exit("IOError! I can't find ",self.plot_in," file!")

        # Looping through my_csv1
        for line in my_csv1:
            if line[0] == "#":
                continue
            elif line[0].strip() == "type_plot":
                self.type_plot = line[1]
            elif "title_in" in line:
                self.title_in = line[1]
            elif line[0].strip() == "x_label":
                self.x_label = line[1]
            elif line[0].strip() == "y_label":
                self.y_label = line[1]
            elif line[0].strip() == "r_min":
                self.r_min = float(line[1])
            elif line[0].strip() == "r_max":
                self.r_max = float(line[1])
            elif line[0].strip() == "reqm_i":
                self.reqm_i = float(line[1])
            elif line[0].strip() == "reqm_j":
                self.reqm_j = float(line[1])
            elif line[0].strip() == "epsilon_i":
                self.epsilon_i = float(line[1])
            elif line[0].strip() == "epsilon_j":
                self.epsilon_j = float(line[1])
            elif line[0].strip() == "log_w":
                self.log_w = float(line[1])
            elif line[0].strip() == "tanh_w":
                self.tanh_w = float(line[1])
            elif line[0].strip() == "a_array":
                _1 = float(line[1])
                _2 = float(line[2])
                _3 = int(line[3])
                self.a_array = np.linspace(_1,_2,_3)
            elif line[0].strip() == "e0_array":
                _1 = float(line[1])
                _2 = float(line[2])
                _3 = int(line[3])
                self.e0_array = np.linspace(_1,_2,_3)
            elif line[0].strip() == "k_array":
                _1 = float(line[1])
                _2 = float(line[2])
                _3 = int(line[3])
                self.k_array = np.linspace(_1,_2,_3)
            elif line[0].strip() == "l_array":
                _1 = float(line[1])
                _2 = float(line[2])
                _3 = int(line[3])
                self.l_array = np.linspace(_1,_2,_3)
            elif line[0].strip() == "m_array":
                _1 = int(line[1])
                _2 = int(line[2])
                _3 = int(line[3])
                self.m_array = np.linspace(_1,_2,_3)
            elif line[0].strip() == "n_array":
                _1 = int(line[1])
                _2 = int(line[2])
                _3 = int(line[3])
                self.n_array = np.linspace(_1,_2,_3)
            elif line[0].strip() == "s_array":
                _1 = float(line[1])
                _2 = float(line[2])
                _3 = int(line[3])
                self.s_array = np.linspace(_1,_2,_3)
            else:
                continue

        # Close file
        fo1.close()

    # Define gen_plot() method
    def gen_plot(self):
        """Method to generate plot"""

        # Import section
        import numpy as np
        import matplotlib.pyplot as plt

        # Set up array
        self.r = np.arange(self.r_min,self.r_max, 0.01)

        # Check the type of potential to plot
        if self.type_plot == "VDW":

            # Import vdw from SFSXplorer package
            from SFSXplorer import vdw as vd

            # Instantiating an object of the PairwisePot() class and assign it to VDW
            VDW1 = vd.PairwisePot()

            # Invert array
            m_array_inv = np.flip(self.m_array)

            # Looping through m_array_inv (attraction expoent m = 6)
            for m in m_array_inv:

                # Looping through range(m) (repulsion expoent n = 12)
                for n in range(2,int(m)):

                    # To avoid m== n
                    if m != n :

                        # Invoking potential() method using specific data as arguments
                        _,_,self.v = VDW1.potential(self.reqm_i,self.epsilon_i,self.reqm_j,self.epsilon_j,self.r,m,n)

                        # Plot stuff
                        plt.plot(self.r,self.v)

            # More plot stuff
            plt.ylim(-1.0,0.6)
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Show plot
            #plt.show()

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        elif self.type_plot == "HB":

            # Import hb from SFSXplorer package
            from SFSXplorer import hb as hbp

            # Instantiating an object of the PairwisePotHB() class and assign it to VDW
            HB1 = hbp.PairwisePotHB()

            # Invert array
            m_array_inv = np.flip(self.m_array)

            # Looping through m_array_inv (attraction expoent m = 6)
            for m in m_array_inv:

                # Looping through range(m) (repulsion expoent n = 12)
                for n in range(2,int(m)):

                    # To avoid m== n
                    if m != n :

                        # Invoking potential() method using specific data as arguments
                        _,_,self.v = HB1.potential(self.reqm_i,self.epsilon_i,self.reqm_j,self.epsilon_j,self.r,m,n)

                        # Plot stuff
                        plt.plot(self.r,self.v)

            # More plot stuff
            plt.ylim(-1.0,0.6)
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        elif self.type_plot == "ELE1":

            # Set up charges
            q_i = -4 # Dummy positive charge
            q_j = 4  # Dummy negative charge

            # Looping through l_array, k_array, a_array, and e0_array
            for l in self.l_array:
                for k in self.k_array:
                    for a in self.a_array:
                        for e0 in self.e0_array:

                            # Calculate electrostatic potential
                            ep = self.log_w*self.epsilon0(self.r,l,k,a,e0) + self.tanh_w*self.epsilon0_tanh(self.r,l,k,a,e0)
                            self.v = q_i*q_j/(self.r*ep)   # Coulomb potential

                            # Plot stuff
                            plt.plot(self.r,self.v)

            # More plot stuff
            plt.ylim(-1.0,0.6)
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        elif self.type_plot == "ELE2":

            # Set up charges
            q_i = -4 # Dummy positive charge
            q_j = 4  # Dummy negative charge

            # Looping through l_array, k_array, a_array, and e0_array
            for l in self.l_array:
                for k in self.k_array:
                    for a in self.a_array:
                        for e0 in self.e0_array:

                            # Calculate electrostatic potential
                            ep = self.log_w*self.epsilon0(self.r,l,k,a,e0) + self.tanh_w*self.epsilon0_tanh(self.r,l,k,a,e0)
                            self.v = q_i*q_j/(self.r*ep)   # Coulomb potential

                            # Plot stuff
                            plt.plot(self.r,self.v)

            # More plot stuff
            plt.ylim(-1.0,0.6)
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        elif self.type_plot == "ELE3":

            # Set up charges
            q_i = -4 # Dummy positive charge
            q_j = 4  # Dummy negative charge

            # Looping through l_array, k_array, a_array, and e0_array
            for l in self.l_array:
                for k in self.k_array:
                    for a in self.a_array:
                        for e0 in self.e0_array:

                            # Calculate electrostatic potential
                            ep = self.log_w*self.epsilon0(self.r,l,k,a,e0) + self.tanh_w*self.epsilon0_tanh(self.r,l,k,a,e0)
                            self.v = q_i*q_j/(self.r*ep)   # Coulomb potential

                            # Plot stuff
                            plt.plot(self.r,self.v)

            # More plot stuff
            plt.ylim(-1.0,0.6)
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        elif self.type_plot == "EPSILON":

            # Define parameters
            l = 0.003627
            k = 7.7839
            a = -8.5525
            e0 = 78.4
            self.ep1 = self.epsilon0(self.r,l,k,a,e0)

            # Plot stuff
            plt.plot(self.r,self.ep1,label="Logistic $\epsilon$ ($\lambda$="+str(l)+", k="+str(k)+", A="+str(a)+")")

            # Define parameters
            l = 0.001787
            k = 3.4781
            a = -20.929
            self.ep2 = self.epsilon0(self.r,l,k,a,e0)

            # Plot stuff
            plt.plot(self.r,self.ep2,label="Logistic $\epsilon$ ($\lambda$="+str(l)+", k="+str(k)+", A="+str(a)+")")

            # Define parameters
            l = 0.003627
            k = 7.7839
            a = -8.5525
            self.ep3 = self.epsilon0_tanh(self.r,l,k,a,e0)

            # Plot stuff
            plt.plot(self.r,self.ep3,label="Tanh $\epsilon$ ($\lambda$="+str(l)+", k="+str(k)+", A="+str(a)+")")

            # Define parameters
            l = 0.001787
            k = 3.4781
            a = -20.929
            self.ep4 = self.epsilon0_tanh(self.r,l,k,a,e0)

            # Plot stuff
            plt.plot(self.r,self.ep4,label="Tanh $\epsilon$ ($\lambda$="+str(l)+", k="+str(k)+", A="+str(a)+")")

            # Define parameters
            l = 0.003627
            k = 7.7839
            a = -8.5525
            self.ep5 = 0.5*self.epsilon0_tanh(self.r,l,k,a,e0) + 0.5*self.epsilon0(self.r,l,k,a,e0)

            # Plot stuff
            plt.plot(self.r,self.ep5,label="Logistic+Tanh $\epsilon$ ($\lambda$="+str(l)+", k="+str(k)+", A="+str(a)+")")

            # Define parameters
            l = 0.001787
            k = 3.4781
            a = -20.929
            self.ep6 = 0.5*self.epsilon0_tanh(self.r,l,k,a,e0) + 0.5*self.epsilon0(self.r,l,k,a,e0)

            # Plot stuff
            plt.plot(self.r,self.ep6,label="Logistic+Tanh $\epsilon$ ($\lambda$="+str(l)+", k="+str(k)+", A="+str(a)+")")

            # Positioning the legends
            plt.legend(loc='lower right', prop = {"size":9})

            # More plot stuff
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        elif self.type_plot == "DESOL":

            # Import desolv from SFSXplorer package
            from SFSXplorer import desolv as ds1

            # Instantiating an object of the PairwisePotDesol() class and assign it to DeSol1
            DeSol1 = ds1.PairwisePotDesol()

            # Get parameters
            vol_i,sol_i,vol_j,sol_j = 22.4493, -0.00162,17.1573,-0.00251

            # Looping through self.m_array (m = 2)
            for m in self.m_array:

                # Looping through self.n_array (n = 2)
                for n in self.n_array:

                    # Looping through self.s_array (sigma = 3.5 A)
                    for s in self.s_array:

                        # Invoking potential() method using specific data as arguments
                        self.v = DeSol1.potential(vol_i,sol_i,vol_j,sol_j,self.r,m,n,s)

                        # Plot stuff
                        plt.plot(self.r,self.v)

            # More plot stuff
            plt.ylim(-1.0,0.6)
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        elif self.type_plot == "ALL1":

            # van der Waals Potential

            # Import vdw from SFSXplorer package
            from SFSXplorer import vdw as vd

            # Instantiating an object of the PairwisePot() class and assign it to VDW
            VDW = vd.PairwisePot()

            # Invoking potential() method using specific data as arguments
            _,_,self.v1 = VDW.potential(4.00,0.150,4.00,0.15,self.r,6,12)

            # Hydrogen-bond Potential

            # Import hb from SFSXplorer package
            from SFSXplorer import hb as hb

            # Instantiating an object of the PairwisePotHB() class and assign it to HB
            HB1 = hbp.PairwisePotHB()

            # Invoking potential() method using specific data as arguments
            _,_,self.v2 = HB1.potential(1.9,5.0,1.9,5.0,self.r,10,12)

            # Electrostatic potential

            # Set up charges
            q_i = -4 # Dummy positive charge
            q_j = 4  # Dummy negative charge

            # Calculate electrostatic potential with logistic function as epsilon
            l = 0.003627
            k = 7.7839
            A = -8.5525
            e0 = 78.4
            ep = self.log_w*self.epsilon0(self.r,l,k,A,e0) + self.tanh_w*self.epsilon0_tanh(self.r,l,k,A,e0)
            self.v3 = q_i*q_j/(self.r*ep)   # Coulomb potential

            # Desolvation potential

            # Import desolv from SFSXplorer package
            from SFSXplorer import desolv as ds1

            # Instantiating an object of the PairwisePotDesol() class and assign it to DeSol1
            DeSol1 = ds1.PairwisePotDesol()

            # Get parameters
            vol_i,sol_i,vol_j,sol_j = 22.4493, -0.00162,17.1573,-0.00251

            # Invoking potential() method using specific data as arguments
            self.v6 = DeSol1.potential(vol_i,sol_i,vol_j,sol_j,self.r,2,2,3.5)

            # Sum potentials without weight
            all_pot = self.v1 + self.v2 + self.v3 + self.v6

            # Plot stuff
            plt.plot(self.r,self.v1,label="Repulsion/Attraction")
            plt.plot(self.r,self.v2,label="Hydrogen Bonds")
            plt.plot(self.r,self.v3,label="Electrostatics (Logistic $\epsilon$)")
            plt.plot(self.r,self.v6,label="Desolvation")
            plt.plot(self.r,all_pot,label="Summation of Potentials")

            # Positioning the legends
            plt.legend(loc='upper right')

            # More plot stuff
            plt.ylim(-1.0,0.6)
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        elif self.type_plot == "ALL2":

            # van der Waals Potential

            # Import vdw from SFSXplorer package
            from SFSXplorer import vdw as vd

            # Instantiating an object of the PairwisePot() class and assign it to VDW
            VDW = vd.PairwisePot()

            # Invoking potential() method using specific data as arguments
            _,_,self.v1 = VDW.potential(4.00,0.150,4.00,0.15,self.r,6,12)

            # Hydrogen-bond Potential

            # Import hb from SFSXplorer package
            from SFSXplorer import hb as hb

            # Instantiating an object of the PairwisePotHB() class and assign it to HB
            HB1 = hbp.PairwisePotHB()

            # Invoking potential() method using specific data as arguments
            _,_,self.v2 = HB1.potential(1.9,5.0,1.9,5.0,self.r,10,12)

            # Electrostatic potential

            # Set up charges
            q_i = -4 # Dummy positive charge
            q_j = 4  # Dummy negative charge

            # Calculate electrostatic potential with tanh function as epsilon
            l = 0.003627
            k = 7.7839
            A = -8.5525
            e0 = 78.4
            ep = self.log_w*self.epsilon0(self.r,l,k,A,e0) + self.tanh_w*self.epsilon0_tanh(self.r,l,k,A,e0)
            self.v4 = q_i*q_j/(self.r*ep)   # Coulomb potential

            # Desolvation potential

            # Import desolv from SFSXplorer package
            from SFSXplorer import desolv as ds1

            # Instantiating an object of the PairwisePotDesol() class and assign it to DeSol1
            DeSol1 = ds1.PairwisePotDesol()

            # Get parameters
            vol_i,sol_i,vol_j,sol_j = 22.4493, -0.00162,17.1573,-0.00251

            # Invoking potential() method using specific data as arguments
            self.v6 = DeSol1.potential(vol_i,sol_i,vol_j,sol_j,self.r,2,2,3.5)

            # Sum potentials without weight
            all_pot = self.v1 + self.v2 + self.v4 + self.v6

            # Plot stuff
            plt.plot(self.r,self.v1,label="Repulsion/Attraction")
            plt.plot(self.r,self.v2,label="Hydrogen Bonds")
            plt.plot(self.r,self.v4,label="Electrostatics (Tanh $\epsilon$)")
            plt.plot(self.r,self.v6,label="Desolvatation")
            plt.plot(self.r,all_pot,label="Summation of Potentials")

            # Positioning the legends
            plt.legend(loc='upper right')

            # More plot stuff
            plt.ylim(-1.0,0.6)
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        elif self.type_plot == "ALL3":

            # van der Waals Potential

            # Import vdw from SFSXplorer package
            from SFSXplorer import vdw as vd

            # Instantiating an object of the PairwisePot() class and assign it to VDW
            VDW = vd.PairwisePot()

            # Invoking potential() method using specific data as arguments
            _,_,self.v1 = VDW.potential(4.00,0.150,4.00,0.15,self.r,6,12)

            # Hydrogen-bond Potential

            # Import hb from SFSXplorer package
            from SFSXplorer import hb as hb

            # Instantiating an object of the PairwisePotHB() class and assign it to HB
            HB1 = hbp.PairwisePotHB()

            # Invoking potential() method using specific data as arguments
            _,_,self.v2 = HB1.potential(1.9,5.0,1.9,5.0,self.r,10,12)

            # Electrostatic potential

            # Set up charges
            q_i = -4 # Dummy positive charge
            q_j = 4  # Dummy negative charge

            # Calculate electrostatic potential with tanh function as epsilon
            l = 0.003627
            k = 7.7839
            A = -8.5525
            e0 = 78.4
            ep = self.log_w*self.epsilon0(self.r,l,k,A,e0) + self.tanh_w*self.epsilon0_tanh(self.r,l,k,A,e0)
            self.v5 = q_i*q_j/(self.r*ep)   # Coulomb potential

            # Desolvatation Potential

            # Import desolv from SFSXplorer package
            from SFSXplorer import desolv as ds1

            # Instantiating an object of the PairwisePotDesol() class and assign it to DeSol1
            DeSol1 = ds1.PairwisePotDesol()

            # Get parameters
            vol_i,sol_i,vol_j,sol_j = 22.4493, -0.00162,17.1573,-0.00251

            # Invoking potential() method using specific data as arguments
            self.v6 = DeSol1.potential(vol_i,sol_i,vol_j,sol_j,self.r,2,2,3.5)

            # Sum potentials without weight
            all_pot = self.v1 + self.v2 + self.v5 + self.v6

            # Plot stuff
            plt.plot(self.r,self.v1,label="Repulsion/Attraction")
            plt.plot(self.r,self.v2,label="Hydrogen Bonds")
            plt.plot(self.r,self.v5,label="Electrostatics (Logistic+Tanh $\epsilon$)")
            plt.plot(self.r,self.v6,label="Desolvatation")
            plt.plot(self.r,all_pot,label="Summation of Potentials")

            # Positioning the legends
            plt.legend(loc='upper right')

            # More plot stuff
            plt.ylim(-1.0,0.6)
            plt.grid()
            plt.xlabel(self.x_label)
            plt.ylabel(self.y_label)
            plt.title(self.title_in)

            # Save and show plot
            plt.savefig(self.plot_out,dpi=self.dpi_in)
            plt.show()

        # Show message
        print("Done!")

    # Define epsilon0() method
    def epsilon0(self,r,l,k,A,e0):
        """Method to calcule sigmoidal distance-dependent dielectric function """

        # Import library
        import numpy as np

        # Set up constants
        # taken from http://autodock.scripps.edu/faqs-help/manual/autodock-3-user-s-guide/AutoDock3.0.5_UserGuide.pdf
        #A = -8.5525
        #l = 0.003627
        #k = 7.7839
        #e0 = 78.4       # Dielectric constant of bulk water at 25˚C
        B = e0 - A

        # A sigmoidal distance-dependent dielectric function is used to model solvent
        # screening,based on the work of Mehler and Solmajer.
        # Mehler, E.L. and Solmajer, T. (1991) “Electrostatic effects in proteins: comparison of
        # dielectric and charge models” Protein Engineering, 4, 903-910.
        e0_r = A + B/(1+k*np.exp(-l*B*r))

        # Return result
        return e0_r

    # Define epsilon0_tanh() method
    def epsilon0_tanh(self,r,l,k,A,e0):
        """Method to calcule distance-dependent dielectric function using tanh"""

        # Import library
        import numpy as np

        # Set up constants
        # taken from http://autodock.scripps.edu/faqs-help/manual/autodock-3-user-s-guide/AutoDock3.0.5_UserGuide.pdf
        #A = -8.5525
        #l = 0.003627
        #k = 7.7839
        #e0 = 78.4       # Dielectric constant of bulk water at 25˚C
        B = e0 - A

        # A sigmoidal distance-dependent dielectric function is used to model solvent
        # screening,based on the work of Mehler and Solmajer.
        # Mehler, E.L. and Solmajer, T. (1991) “Electrostatic effects in proteins: comparison of
        # dielectric and charge models” Protein Engineering, 4, 903-910.
        #e0_r = A + B/(1+k*np.exp(-l*B*r))
        #e0_r = A + B*(1/2+(k/2)*np.tanh(l*B*r/2))
        #e0_r = A + B*(1/2+(1/2)*np.tanh(l*B*r/2)) OK!
        #e0_r = A + B*(1/2+(1/2)*np.tanh(l*B*r/2))
        e0_r = A + B*(np.exp(l*B*r)-k*np.exp(-l*B*r))/(np.exp(l*B*r)+k*np.exp(-l*B*r))

        # Return result
        return e0_r

    # Define epsilon0_arctan() method
    def epsilon0_arctan(self,r,l,k,A,e0):
        """Method to calcule distance-dependent dielectric function using arctan function"""

        # Import library
        import numpy as np

        # Set up constants
        # taken from http://autodock.scripps.edu/faqs-help/manual/autodock-3-user-s-guide/AutoDock3.0.5_UserGuide.pdf
        #A = -8.5525
        #l = 0.003627
        #k = 7.7839
        #e0 = 78.4       # Dielectric constant of bulk water at 25˚C
        B = e0 - A

        # A sigmoidal distance-dependent dielectric function is used to model solvent
        # screening,based on the work of Mehler and Solmajer.
        # Mehler, E.L. and Solmajer, T. (1991) “Electrostatic effects in proteins: comparison of
        # dielectric and charge models” Protein Engineering, 4, 903-910.
        #e0_r = A + B/(1+k*np.exp(-l*B*r))
        #e0_r = A + B*(1/2+(k/2)*np.tanh(l*B*r/2))
        #e0_r = A + B*(1/2+(1/2)*np.tanh(l*B*r/2)) OK!
        #e0_r = A + B*(1/2+(1/2)*np.tanh(l*B*r/2))
        #e0_r = A + B*(np.exp(l*B*r)-k*np.exp(-l*B*r))/(np.exp(l*B*r)+k*np.exp(-l*B*r))
        #e0_r = A + B*(1/np.sqrt(2))*np.arctan(l*B*r) # OK!
        #e0_r = A + B*np.arctan(k*l*r)
        e0_r = A + B*(np.exp(1)/np.sqrt(2*k))*np.arctan(l*B*r) # OK!

        # Return result
        return e0_r