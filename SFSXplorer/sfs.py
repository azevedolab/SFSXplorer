#!/usr/bin/env python3
#
################################################################################
# SFSXplorer                                                                   #
# Scoring Function Space eXplorer                                              #
################################################################################
#
# SFSXplorer reads input files generated by SAnDReS 2.0 (Xavier et al., 2016)
# (pdbqt and bind_#####.csv files) to create targeted scoring functions
# (Seifert, 2009). This program calculates energy terms loosely based on the
# AutoDock 4 Force Field (Morris et al., 1998; 2009) to explore the
# Scoring Function Space concept (Ross et al., 2013; Heck et al., 2017;
# Bitencourt-Ferreira & de Azevedo Jr., 2019; Veríssimo et al., 2022). We may
# vary the exponents of van der Waals and hydrogen-bond potentials and the
# parameters used to determine the electrostatic (Bitencourt-Ferreira & de
# Azevedo Jr., 2021) and desolvation potentials.
#
# References:
# Bitencourt-Ferreira G, de Azevedo WF Jr. Exploring the Scoring Function Space.
# Methods Mol Biol. 2019; 2053: 275–281.
#
# Bitencourt-Ferreira G, de Azevedo Junior WF. Electrostatic Potential Energy in
# Protein-Drug Complexes. Curr Med Chem. 2021; 28(24): 4954–4971.
#
# Heck GS, Pintro VO, Pereira RR, de Ávila MB, Levin NMB, de Azevedo WF.
# Supervised Machine Learning Methods Applied to Predict Ligand-Binding
# Affinity. Curr Med Chem. 2017; 24(23): 2459–2470.
#
# Morris GM, Goodsell D, Halliday R, Huey R, Hart W, Belew R, Olson A.
# Automated docking using a Lamarckian genetic algorithm and an empirical
# binding free energy function. J Comput Chem. 1998; 19: 1639–1662.
#
# Morris GM, Huey R, Lindstrom W, Sanner MF, Belew RK, Goodsell DS, Olson AJ.
# AutoDock4 and AutoDockTools4: Automated docking with
# selective receptor flexibility. J Comput Chem. 2009; 30(16): 2785–2791.
#
# Ross GA, Morris GM, Biggin PC. One Size Does Not Fit All: The Limits of
# Structure-Based Models in Drug Discovery. J Chem Theory Comput. 2013; 9(9):
# 4266–4274.
#
# Seifert MH. Targeted scoring functions for virtual screening. Drug Discov
# Today. 2009; 14(11-12): 562–569.
#
# Xavier MM, Heck GS, Avila MB, Levin NMB, Pintro VO, Carvalho NL, Azevedo WF.
# SAnDReS: a Computational Tool for Statistical Analysis of Docking Results and
# Development of Scoring Functions. Comb Chem High Throughput Screen. 2016;
# 9(10):801–812.
#
# Veríssimo GC, Serafim MSM, Kronenberger T, Ferreira RS, Honorio KM,
# Maltarollo VG. Designing drugs when there is low data availability:
# one-shot learning and other approaches to face the issues of a
# long-term concern. Expert Opin Drug Discov. 2022; 17(9): 929–947.
#
################################################################################
# Dr. Walter F. de Azevedo, Jr.                                                #
# https://azevedolab.net/                                                      #
# January 12, 2023                                                             #
################################################################################
#
# Import section
import sys
import numpy as np
from SFSXplorer import FF_AD4 as ad4

# Define Explorer() class
class Explorer(object):
    """A class to explore the scoring function space"""	

    # Define the constructor method
    def __init__(self,sfs_in):
        """Constructor method"""
        
        # Set up attributes
        self.sfs_in = sfs_in

        # Show message
        print("\nExploring the Scoring Function Space...")

    # Define read_input() method
    def read_input(self):
        """Method to read input data"""
        
        # Import section
        import csv
        
        # Define function to handle hash in number field (float or integer)
        def handle_hash(type_in,line_in):
            """Function to handle hash in number field and returns a float or
            an integer"""
            
            # Test type
            if type_in == "float":
                # Handle hash for float output
                try:
                    index_hash = str(line_in).index("#")
                    number_out = float(line_in[:index_hash])
                except:
                    number_out = float(line_in)
            elif type_in == "int":
                # Handle hash for integer output
                try:
                    index_hash = str(line_in).index("#")
                    number_out = int(line_in[:index_hash])
                except:
                    number_out = int(line_in)
            else:
                # Print error message and exit
                sys.exit("\nError! Not defined type of number!")
            
            # Return number
            return number_out
            
        # Try to open sfs.in file
        try:
            fo = open(self.sfs_in,"r")
            csv = csv.reader(fo)
        except IOError:
            msg_out = "\nI can't find "+self.sfs_in+" file!"
            msg_out += "Finishing execution."
            sys.exit(msg_out)
        
        # Looping through input file with commands (e.g., sfs.in)
        for line in csv:
            if line[0] == "#":
                continue
            elif line[0].strip() == "dataset_dir":
                self.dataset_dir = str(line[1])
            elif line[0].strip() == "ligands_in":
                self.ligands_in = str(line[1])
            elif line[0].strip() == "scores_out":
                self.scores_out = str(line[1])
            elif line[0].strip() == "binding_type":
                self.binding_type = str(line[1])
            
            # For van der Waals potential
            elif line[0].strip() == "pot_VDW_m_min":
                self.pot_VDW_m_min = handle_hash("int",line[1])
            elif line[0].strip() == "pot_VDW_m_max":
                self.pot_VDW_m_max = handle_hash("int",line[1])
            elif line[0].strip() == "pot_VDW_n_min":
                self.pot_VDW_n_min = handle_hash("int",line[1])
            elif line[0].strip() == "pot_VDW_n_max":
                self.pot_VDW_n_max = handle_hash("int",line[1])
            
            # For hydrogen-bond potential
            elif line[0].strip() == "pot_HB_m_min":
                self.pot_HB_m_min = handle_hash("int",line[1])
            elif line[0].strip() == "pot_HB_m_max":
                self.pot_HB_m_max = handle_hash("int",line[1])
            elif line[0].strip() == "pot_HB_n_min":
                self.pot_HB_n_min = handle_hash("int",line[1])
            elif line[0].strip() == "pot_HB_n_max":
                self.pot_HB_n_max = handle_hash("int",line[1])
            
            # For electrostatic potential (set up parameters for arrays)
            elif line[0].strip() == "lambda_i":
                self.lambda_i =  handle_hash("float",line[1])                    
            elif line[0].strip() == "lambda_f":
                self.lambda_f =  handle_hash("float",line[1])  
            elif line[0].strip() == "n_lambda":
                self.n_lambda = handle_hash("int",line[1])
            
            elif line[0].strip() == "k_i":
                self.k_i = handle_hash("float",line[1])
            elif line[0].strip() == "k_f":
                self.k_f = handle_hash("float",line[1])
            elif line[0].strip() == "n_k":
                self.n_k = handle_hash("int",line[1])
            
            elif line[0].strip() == "A_i":
                self.A_i = handle_hash("float",line[1])
            elif line[0].strip() == "A_f":
                self.A_f = handle_hash("float",line[1])
            elif line[0].strip() == "n_A":
                self.n_A = handle_hash("int",line[1])
            
            elif line[0].strip() == "epsilon0_i":
                self.epsilon0_i = handle_hash("float",line[1])
            elif line[0].strip() == "epsilon0_f":
                self.epsilon0_f = handle_hash("float",line[1])
            elif line[0].strip() == "n_epsilon0":
                self.n_epsilon0 = handle_hash("int",line[1])
            
            # For desolvation potential (set up parameters for arrays)
            elif line[0].strip() == "m_desol_i":
                self.m_desol_i = handle_hash("int",line[1])
            elif line[0].strip() == "m_desol_f":
                self.m_desol_f = handle_hash("int",line[1])
            elif line[0].strip() == "n_m_desol":
                self.n_m_desol = handle_hash("int",line[1])
            
            elif line[0].strip() == "n_desol_i":
                self.n_desol_i = handle_hash("int",line[1])
            elif line[0].strip() == "n_desol_f":
                self.n_desol_f = handle_hash("int",line[1])
            elif line[0].strip() == "n_n_desol":
                self.n_n_desol = handle_hash("int",line[1])
                
            elif line[0].strip() == "sigma_desol_i":
                self.sigma_desol_i = handle_hash("float",line[1])
            elif line[0].strip() == "sigma_desol_f":
                self.sigma_desol_f = handle_hash("float",line[1])
            elif line[0].strip() == "n_sigma_desol":
                self.n_sigma_desol = handle_hash("int",line[1])
                
        # Close file
        fo.close()
        
    # Define read_data() method
    def read_data(self):
        """Method to read data ligands.in"""
        
        # Import section
        import csv

        # Open csv file
        self.fo0 = open(self.ligands_in,"r")
        self.csv0 = csv.reader(self.fo0)

    # Define write_energy() method
    def write_energy(self):
        """Method to write energy terms"""
        
        # Open scores_ff_all.csv
        self.fo1 = open(self.scores_out,"w")
        
        ########################################################################
        # For van der Waals potential
        
        # Set up headers
        headers_VDW = ""
        for n_exp in range(self.pot_VDW_n_min,self.pot_VDW_n_max+1):
            for m_exp in range(self.pot_VDW_m_min,self.pot_VDW_m_max+1):
                # To avoid n_exp == m_exp
                if n_exp != m_exp:
                    headers_VDW += "v_VDW_"+str(n_exp)+"_"+str(m_exp)+","
        
        ########################################################################
        # For van der Waals potential
        
        # Set up headers
        headers_HB = ""
        for n_exp in range(self.pot_HB_n_min,self.pot_HB_n_max+1):
            for m_exp in range(self.pot_HB_m_min,self.pot_HB_m_max+1):
                # To avoid n_exp == m_exp
                if n_exp != m_exp:
                    headers_HB += "v_HB_"+str(n_exp)+"_"+str(m_exp)+","
        
        # Put together van der Waals and hydrogen bond potentials
        terms_VDW_HB = headers_VDW+headers_HB 

        ########################################################################
        # For Electrostatic Potential
                
        # Set up arrays
        a_array = np.linspace(self.A_i,self.A_f,self.n_A)
        e0_array = np.linspace(self.epsilon0_i,self.epsilon0_f,self.n_epsilon0)
        k_array = np.linspace(self.k_i,self.k_f,self.n_k)
        l_array = np.linspace(self.lambda_i,self.lambda_f,self.n_lambda)
                                
        # Set up empty strings
        v_Elec_logistic_terms = ""
        v_Elec_tanh_terms = ""
        v_Elec_logistic_tanh_terms = ""
                                
        # Looping through a_array, e0_array, k_array, and l_array
        for a in a_array:
            for e0 in e0_array:
                for k in k_array:
                    for l in l_array:
                                
                        # Set up headers for electrostatic potential
                        v_Elec_logistic_terms += "v_Elec_Log_"+str(a)+"_"+\
                        str(e0)+"_"+str(k)+"_"+str(l)+","
                        v_Elec_tanh_terms += "v_Elec_Tanh_"+str(a)+"_"+\
                        str(e0)+"_"+str(k)+"_"+str(l)+","
                        v_Elec_logistic_tanh_terms += "v_Elec_Log_Tanh_"+\
                        str(a)+"_"+str(e0)+"_"+str(k)+"_"+str(l)+","
                                
        ########################################################################
        # For desolvation potentials
                
        # Set up empty string
        v_Desol_terms = ""
        
        # Set up arrays
        m_array_desol = np.linspace(self.m_desol_i,self.m_desol_f,self.n_m_desol)
        n_array_desol = np.linspace(self.n_desol_i,self.n_desol_f,self.n_n_desol)
        s_array_desol = np.linspace(self.sigma_desol_i,self.sigma_desol_f,
                                    self.n_sigma_desol)
                
        # Looping through m_array_desol, n_array_desol, and s_array_desol
        for m in m_array_desol:
            for n in n_array_desol:
                for sigma in s_array_desol:
            
                    # Set up headers for desolvation potential
                    v_Desol_terms+="v_Desol_"+str(m)+"_"+str(n)+"_"+str(sigma)+","
                                
        ########################################################################
        # Instantiating an object of the InterMol() class and assign it to pot.
        # It uses AutoDock4 force field parameters.
        pot = ad4.InterMol("misc/data/AD4.1_bound.dat")
        
        # Set up an empty string
        header_in = ""
        
        # Looping through csv0 to get the headers
        for line in self.csv0:
            
            # Looping through the header
            for i,ele in enumerate(line):
                header_in += line[i]+","

            break
        
        # Write header
        line_out = header_in+terms_VDW_HB+v_Elec_logistic_terms
        line_out += v_Elec_tanh_terms+v_Elec_logistic_tanh_terms
        line_out += v_Desol_terms[:len(v_Desol_terms)-1]
        self.fo1.write(line_out+"\n")
                    
        # Looping through csv0
        for line in self.csv0:
    
            # Check keyword to get ligand data
            if line[0].strip() != "PDB" and "#" not in line[0].strip():
            
                # Assign directory for a specific PDB to name_dir 
                name_dir = self.dataset_dir+str(line[0].strip())+"/" 
        
                # Show from where it is reading
                print(name_dir)
        
                # Invoking read_AD4_bound() method
                par_list = pot.read_AD4_bound()
        
                # Invoking read_PDBQT() method
                lig_list = pot.read_PDBQT(name_dir+"lig.pdbqt")
        
                # Invoking read_PDBQT() method
                receptor_list = pot.read_PDBQT(name_dir+"receptor.pdbqt")
        
                ################################################################
                # Calculate van der Waals potentials
                string_VDW = ""
                for n_exp in range(self.pot_VDW_n_min,self.pot_VDW_n_max+1):
                    for m_exp in range(self.pot_VDW_m_min,self.pot_VDW_m_max+1):
                        # To avoid n_exp == m_exp
                        if n_exp != m_exp:
                            v_VDW_n_m = pot.intermol_pot_VDW(par_list,lig_list,
                                    receptor_list,n_exp,m_exp) 
                            string_VDW += ","+str(v_VDW_n_m) 
                
                ################################################################
                # Calculate hydrongen-bond potentials
                string_HB = ""
                for n_exp in range(self.pot_HB_n_min,self.pot_HB_n_max+1):
                    for m_exp in range(self.pot_HB_m_min,self.pot_HB_m_max+1):
                        # Avoid n_exp == m_exp
                        if n_exp != m_exp:
                            v_HB_n_m = pot.intermol_pot_HB(par_list,lig_list,
                            receptor_list,n_exp,m_exp) 
                            string_HB += ","+str(v_HB_n_m) 
                
                ################################################################
                # For Electrostatic Potential (Logistic Function)
                                
                # Set up empty string
                v_Elec_logistic = ""
                
                # Set up weights for logistic function
                log_w = 1.0
                tanh_w = 0.0
                
                # Looping through a_array, e0_array, k_array, and l_array
                for a in a_array:
                    for e0 in e0_array:
                        for k in k_array:
                            for l in l_array:
                                
                                # Invoking intermol_electro() method 
                                v_Elec_pot = pot.intermol_electro(lig_list,
                                        receptor_list,l,k,a,e0,log_w,tanh_w)
                                v_Elec_logistic +=str(v_Elec_pot)+","

                ################################################################
                # For Electrostatic Potential (Hyperbolic Tangent Function)
                                
                # Set up empty string
                v_Elec_tanh = ""
                
                # Set up weights for hyperbolic tangent function
                log_w = 0.0
                tanh_w = 1.0
                
                # Looping through a_array, e0_array, k_array, and l_array
                for a in a_array:
                    for e0 in e0_array:
                        for k in k_array:
                            for l in l_array:
                                
                                # Invoking intermol_electro() method 
                                v_Elec_pot = pot.intermol_electro(lig_list,
                                        receptor_list,l,k,a,e0,log_w,tanh_w)
                                v_Elec_tanh +=str(v_Elec_pot)+","                
                
                ################################################################
                # For Electrostatic Potential (Logistic + 
                # Hyperbolic Tangent Function)
                                
                # Set up empty string
                v_Elec_logistic_tanh = ""
                
                # Set up weights for hyperbolic tangent function
                log_w = 0.5
                tanh_w = 0.5
                
                # Looping through a_array, e0_array, k_array, and l_array
                for a in a_array:
                    for e0 in e0_array:
                        for k in k_array:
                            for l in l_array:
                                
                                # Invoking intermol_pot_Desol() method 
                                v_Elec_pot = pot.intermol_electro(lig_list,
                                receptor_list,l,k,a,e0,log_w,tanh_w)
                                v_Elec_logistic_tanh +=str(v_Elec_pot)+"," 
                
                ################################################################
                # For desolvation potential
                
                # Set up empty string
                v_Desol = ""
                                
                # Looping through m_array_desol, n_array_desol, and s_array_desol
                for m in m_array_desol:
                    for n in n_array_desol:
                        for sigma in s_array_desol:
            
                            # Invoking intermol_pot_Desol() method
                            v_Desol_pot = pot.intermol_pot_Desol(par_list,lig_list,
                            receptor_list,m,n,sigma)
                            v_Desol += str(v_Desol_pot)+","
                                
                ################################################################
                # Set up line_VDW_HB
                line_VDW_HB = string_VDW+string_HB 
                
                # Set up an empty string
                data_in = ""
        
                # Looping through the data (from bind_####.csv)
                for count,ele in enumerate(line):
                    data_in += line[count]+","
                
                # Write line
                self.fo1.write(data_in[:len(data_in)-3]+\
                line_VDW_HB+","+v_Elec_logistic+\
                v_Elec_tanh+v_Elec_logistic_tanh+v_Desol[:len(v_Desol)-1]+"\n")
        
        # Close files
        self.fo0.close()
        self.fo1.close()
        print("\nDone!")